# Inside of data-strutures, algorithms and heuristics

This section pops the abstraction level and examines the main data-structures, organization, 
algorithms and heuristics that are central to implementation of Z3. We examine the data-structures
used for terms and formulas and then describe the setting for how theory solvers interact 
with the main CDCL(T) engine. 

## Terms and Formulas

Z3 treats terms and formulas as a single entity, expressions. Expressions of Boolean type can be used as formulas, 
but they can also be nested within non-Boolean terms, as arguments to functions. Expressions are _hash-consed_, meaning
they are unique up to term structure. It uses a hash-table when constructing a fresh term, such that if the same function
is applied to the same arguments as a previously constructed term, 
the result of creating the term is the same pointer as old term.

Variables that are to be bound by quantifiers are indexed using de-Brujin conventions, 
such that the index used for the inner-most quantified variable is 0, and incremented outwards.
For example $\exists x \forall y, z, p(x, y, z)$ uses de-Bruijn indices 0 for $z$ and 1 for $y$, and 2 for $x$.
To spare users an error-prone process of keeping track of indices, 
the external API offers a facility to create a quantified expression using a set of constant expressions instead of
variables. 

<!---
* term structure
  * free/bound variable de-Bruijn index
  * function and arguments
  * quantifier
* hash-cons
* Lambdas as arrays
--->

## Interaction with the CDCL(T) core

In Z3, the solver for the theory of equality acts as a gate-keeper between the SAT solver and solvers for other theories.
As Section [#sec-cdcl-t] outlines, the SAT solver maintains a set of ground clauses $F$ and performs case splits and 
propagations and in this process consults the theory solver $\Theory(M;F)$ for the next propagation, case split or
whether $M$ is a theory consistent model of $F$.

There is a good reason why the theory of equality is central: this theory is shared among all other theories.
Disjoint theory solvers establish satisfiability by reconciling equalities among shared sub-terms.

Every E-node has an attached set of theory solvers. A theory solver for a theory $T$ gets attached to a node $n$ when

* $n.f$, the function symbol of $n$, is from the signature of $T$.
* $n.P$, a parent of $n$, belongs to $T$.
* The sort of $n$ is handled by $T$.

Then, when a Boolean node $n$ is assigned to $\true$ or $\false$ by the CDCL solver, the truth assignment to $n$
is broadcast to all solvers attached to $n$. 
Similarly, when two nodes $n, n'$ are merged, and the theory $T$ is attached to a sibling of $n$ and a sibling of $n'$, 
then the equality $n \simeq n'$ is broadcast to $T$.

In some cases the core also broadcasts disequalities between E-nodes. 
Solvers cannot rely on complete propagation of disequalities, it is generally 
too costly to enumerate all pairwise disequalities.
Propagation of disequalities is triggered by when the CDCL(T) core asserts a
disequality $n \not\simeq n'$, or when a theory solver propagates a disequality.

* Common data-structures for theories

### Model-based theory combination

### Relevancy filtering

### The power of propagation

### Iterative deepening for finite models

### Incrementality

* External and internal scopes
* Undo-trail
* equi-satisfiability

