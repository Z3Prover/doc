# Quantifiers

## Quantifier Engines in Z3

* E-matching [@MouraB07] 

* Model-based Quantifier Instantiation (MBQI) [@GeM09;@MouraB10;@BonacinaLM11;@WintersteigerHM13] 

* Quantifier Elimination and Satifiability [@BjornerAbstract10;@PhanBM12;@BjornerJ15] 

* Horn Clauses [@HoderB12;@BjornerMR13;@GurfinkelEtAl] 

* Deprecated: [@PiskacMB10] EPR using relational algebra, [@MouraB08a] Superposition, see also [VampireZ3]

[VampireZ3]: https://vprover.github.io "VampireZ3"


## E-matching

Let us start with an example of quantifier instantiation using E-matching in action.

~ Begin Example

Consider the formula 

~~ Math
  \underbrace{(\forall x \ . \ f(g(x,c)) \simeq a)}_{p_\varphi} \land b \simeq c \land g(c,b) \simeq c \land f(b) \not\simeq a
~~

The smallest subterm properly containing the bound variable $x$ is ${\color{red}g(x,c)}$ in $f({\color{red}g(x,c)}) \simeq a$.
The only other occurrence of the function $g$ is $g(c,b)$ in the equality $g(c,b) \simeq c$.
Based on the ground equality $b = c$ $g(c,c) \sim g(c,b)$ so we can instantiate $x$ by $c$ and infer

~~ Math
  p_{\varphi} \rightarrow f(g(b,c)) \simeq a
~~ 
The formulas are now ground unsatisfiable.

~ End Example


Quantifier instantiation using E-matching in Z3 serves a sweet spot by producing instantiations that take 
congruences of equalities into account, quickly, across a large set of terms and incrementally.

### E-matching - basic algorithm

E-matching is a first-order matching algorithm that takes a congruence closure into account when checking for equality.
We can describe a basic E-matching algorithm as taking

* a _pattern_ that may contain variables, 
* an E-node _n_, with set of equal nodes accessed as _n.siblings_,

and producing substitutions that represent the set of matches for _n_ with respect to _pattern_.


```python    
def match(pattern, \($n$\), \($\theta$\)):
    pattern = pattern\($\theta$\)
    if pattern == \($n$\):
       yield \($\theta$\)
    elif is_var(pattern):
       yield \($\theta[$\)pattern\($\mapsto$\) \($n$\)\($]$\)
    else:
       f(patterns) = pattern
       for f(terms) in \($n.\mathit{siblings}$\):  
          # e.g., with same head function symbol f
          for \($\theta'$\) in matches(patterns, terms, \($\theta$\)):
            yield \($\theta'$\)

def matches(patterns, terms, \($\theta$\)):
    if not patterns:
       yield \($\theta$\)
       return
    for \($\theta'$\) in match(patterns[0], terms[0], \($\theta$\)):
        for \($\theta''$\) in matches(patterns[1:], terms[1:], \($\theta'$\)):
            yield \($\theta''$\)
```

The same algorithm can be presented in equational form with an extra argument $S$
that accumulates substitutions.

~MathPre

 match(x, t, S)     &  =    & \{ \theta[x \mapsto t] \;\mid\; \theta \in S, x \not\in \theta \} 
                    &       & \cup  \{ \theta \;\mid\; \theta \in S, x \in \theta, \theta(x) \in t.\mathit{siblings} \}
 match(c, t, S)     &  =    & \emptyset\                 \mathsf{if} c \not\in t.\mathit{siblings}
 match(c, t, S)     &  =    & S                 \mathsf{if} c \in t.\mathit{siblings}
 match(f(ps), t, S) &  =    & \bigcup_{f(ts) \in cc(t)} match(ps_n, ts_n, \ldots, 
                    &       &                                 match(ps_1, ts_n, S))
~

### E-matching - code trees 

The straight-forward E-matching algorithm is expensive when it is invoked from scratch for every possible 
candiate of pattern and node during search. To share work across patterns and terms Z3 compiles patterns
into a _code tree_ data-structure that contains dynamically compiled set of instructions to perform matching.
The instructions can be regarded as a partial evaluation of the naive algorithm for fixed patterns. The
instruction set allows merging code sequences from different patterns by sharing common prefixes.
Substitutions are stored in registers, backtracking just updates the registers.

The abstract maching machine uses an array of registers $reg[i]$ to store sub-terms. 
Instructions are stored at program counters and each instruction refers to a next program counter.

Consider the following pattern

~ Math
              f(X, g(X,a), h(Y), b)
~ 

It compiles into a sequence of instructions as follows:

|----------|-------------------------|---------------------------------------------------|
| PC       | Instruction             |                                                   |
+----------+-------------------------+---------------------------------------------------+
| $pc_0$   | init(f, $pc_1$)         |    add arguments of $f$ to registers 1-4          |
+----------+-------------------------+---------------------------------------------------|
| $pc_1$   | check(4,$b$,$pc_2$)     |    check if $reg[4]$ is congruent to $b$          | 
+----------+-------------------------+---------------------------------------------------+
| $pc_2$   | bind(2, $g$, 5, $pc_3$) |    bind terms in $reg[2]$ with $g$ to $5-6$       |
+----------+-------------------------+---------------------------------------------------+
| $pc_3$   | compare(1, 5, $pc_4$  ) |    check if $reg[1]$ equals $reg[5]$              |
+----------+-------------------------+---------------------------------------------------+
| $pc_4$   | check(6, $a$, $pc_5$)   |    check if $reg[6]$ is congruent to $a$          |
+----------+-------------------------+---------------------------------------------------+
| $pc_5$   | bind(3, $h$, 7, $pc_6$) |    bind terms in $reg[3]$ with $h$ to $7$         |
+----------+-------------------------+---------------------------------------------------+
| $pc_6$   | yield(1,7)              |    output binding from $reg[1], reg[7]$           |
+----------+-------------------------+---------------------------------------------------+

Let us trace the instructions for the term $f(h(a),g(h({\color{red}{c}}), a), h(c),b)$

|----------|-------------------------|---|------------------------------------------------|
| PC       | Instruction             |   | $f(h(a),g(h({\color{red}{c}}), a), h(c),b)$                      |
+----------+-------------------------+---+------------------------------------------------+
| $pc_0$   | init(f, $pc_1$)         |   | $reg[1:4] \leftarrow h(a), g(h({\color{red}{c}}),a), h(c), b$ |
+----------+-------------------------+---+------------------------------------------------|
| $pc_1$   | check(4,$b$,$pc_2$)     |   | $reg[4] = b$                                   | 
+----------+-------------------------+---+------------------------------------------------+
| $pc_2$   | bind(2, $g$, 5, $pc_3$) |   | $reg[5:6] \leftarrow h({\color{red}{c}}), a$                  |
+----------+-------------------------+---+------------------------------------------------+
| $pc_3$   | compare(1, 5, $pc_4$  ) |   | $reg[1] = h(a) \neq h({\color{red}{c}}) = reg[5]$             |
+----------+-------------------------+---+------------------------------------------------+
| $pc_4$   | check(6, $a$, $pc_5$)   |                                                   ||
+----------+-------------------------+---------------------------------------------------||
| $pc_5$   | bind(3, $h$, 7, $pc_6$) |                                                   ||
+----------+-------------------------+---------------------------------------------------||
| $pc_6$   | yield(1,7)              |                                                   ||
+----------+-------------------------+---------------------------------------------------||


If we instead use the term $f(h(a),g(h({\color{blue}{a}}), a), h(c),b)$, we get the following execution

|----------|-------------------------|---|------------------------------------------------|
| PC       | Instruction             |   | $f(h(a),g(h({\color{blue}{a}}), a), h(c),b)$      |
+----------+-------------------------+---+------------------------------------------------+
| $pc_0$   | init(f, $pc_1$)         |   | $reg[1:4] \leftarrow h(a), g(h({\color{blue}{a}}),a), h(c), b$ |
+----------+-------------------------+---+------------------------------------------------|
| $pc_1$   | check(4,$b$,$pc_2$)     |   | $reg[4] = b$                                   | 
+----------+-------------------------+---+------------------------------------------------+
| $pc_2$   | bind(2, $g$, 5, $pc_3$) |   | $reg[5:6] \leftarrow h({\color{blue}{a}}), a$                  |
+----------+-------------------------+---+------------------------------------------------+
| $pc_3$   | compare(1, 5, $pc_4$  ) |   | $reg[1] = h(a) = h({\color{blue}{a}}) = reg[5]   $             |
+----------+-------------------------+---+------------------------------------------------+
| $pc_4$   | check(6, $a$, $pc_5$)   |   | $reg[6] = a$                                   |
+----------+-------------------------+---+------------------------------------------------|
| $pc_5$   | bind(3, $h$, 7, $pc_6$) |   | $reg[7] \leftarrow c$                          |
+----------+-------------------------+---+------------------------------------------------|
| $pc_6$   | yield(1,7)              |   | $X \leftarrow h(a) = reg[1], Y \leftarrow c = reg[7]$ |
+----------+-------------------------+---+------------------------------------------------|


Patterns that share common (top-down) term structure can share code sequences.

  *  This saves on common work.

  *  Use the choice instruction to branch when patterns end up having different sub-terms.

Other instructions are possible, 

   *  forward pruning: lookahead multiple function symbols in immediate subterms before diving into any subterm.

   *  to deal with _multi-patterns_, when maching more than one pattern at a time.

### Inverted path indexing

During search, congruence classes are merged and we would like to learn which merges
should trigger new pattern match attempts. Z3 uses a filter called an _inverted path index_
that trackes when a pattern is potentially useful for matching. 

~ Example
The pattern $f(X, g(X,a), h(Y), b)$ contains the subterm $g(X, a)$ in position 2.
The merge between $n_1$ and $n_2$ can potentially trigger a new match when
$n_1.\mathit{siblings}$ contains a node labeled by $g$, and $n_2$ has a parent labeled by $f$, 
and occurs as a second position of $f$.
~

Z3 pre-computes an index based on $f, g$ pairs like these and check if it is triggered 
for some $f, g$ pair and pattern when nodes $n_1, n_2$ are merged.

## Model-based Quantifier Instantiation [@GeM09;@MouraB10;@BonacinaLM11;@WintersteigerHM13]

Model-based Quantifier Instantiation, MBQI, is based on a simple concept of using ground models
to model check quantifiers, and extracting substitutions from quantifiers that fail the model check.
Conceptually, MBQI uses the procedure:

Check $\psi \land \forall x \ . \ \varphi[{x}]$\

__while__ $\psi$ is SAT with model $M$:\
\ \  __if__  $\neg \varphi^M[{x}]$ is UNSAT __return__ SAT\
\ \  $M \leftarrow $ model for $\neg \varphi^M[{x}]$ \
\ \  find $t$, such that $x \not\in t, t^M = x^M$.\
\ \  $\psi \leftarrow \psi \land \varphi[t]$\
__return__ UNSAT\

where $t^M$ is $t$ partially evaluated using interpretation $M$.

~ Begin Example

Assume we have a model $M := [y \mapsto 3, f(x) \mapsto \mathit{if}\ x = 1\ \mathit{then}\ 3\ \mathit{else} \ 5]$
and term $t :=  y + f(y) + f(z)$.
Then the specialization of $t$ with respect to $M$ is
~~ Math
t^M = 8 + \mathit{if}\ z = 1\ \mathit{then}\ 3\ \mathit{else} \ 5
~~
~ End Example

MBQI offers a powerful setting to perform quantifier reasoning when
the searchspace for instantiation terms is finite. This is the case for several fragments:
EPR, UFBV, Array property fragment, Essentially UF.
MBQI can also be combined with a set of templates to search over instantiation terms.

### EPR

Effectively Propositional Reasoning, also known as Bernays-Schoenfinkel-Ramsey class comprises
for formulas with relations, equalities, universally quantified variables, constants but no functions.
Formally, it can be described as a set of formulas of the form:

~MathPre
EPR & ::= \exists e_1\ldots e_n \forall u_1\ldots u_m F
F   & ::= \bigwedge_i C_i
C   & ::= \bigvee_j L_i
L   & ::= A | \neg A
A   & ::= p(\vec{V}) | V = V'
V   & ::= e_i | u_j
~

EPR is decidable, as seen from a brute-force decision procedure:

* Skolemize 
  * $\forall u_1\ldots u_m F$, the $e_1, \ldots, e_n$ are free constants
* Instantiate 
  * $\bigwedge_{\theta} F\theta$ 
  * where $\theta$ ranges over all bindings of $u_i$ to $e_j$.
* Check ground SAT
* Ground SAT implies finite model of size at most $n$.

MBQI can be used to harness the set of groundings.

* Skolemize
  * $\forall u_1\ldots u_m F$, the $e_1, \ldots, e_n$ are free constants

* Models for $\neg F$ bind variables $u_1, \ldots, u_m$ to free constants

* The number of possible such models is bounded by $m^n$.


### UFBV [@WintersteigerHM13]

~ MathPre
F   & ::= \exists e : bv[n] . F | \exists u : bv[n] . F | F \wedge F | C
C   & ::= \bigvee_j L_i
L   & ::= A | \neg A
A   & ::= p(\vec{T}) | T = T' | \mathtt{bvle}(T, T') | \ldots
T   & ::= f(\vec{T}) | u | v | \mbox{bit-vector expression}
bv[n] & ::= \mbox{bit-vector of length $n$}
~


UFBV is decidable:

* All variables range over finite domains.

* Quantifier-free fragment is not only NP hard, it is NEXPTIME hard.
  * QF-UFBV can be encoded into EPR. [@SeidlLB12]

* Quantified fragment is another complexity jump.

* BV - quantifier elimination [@JohnC16;@JohnC13;@JohnC11]

* UFBV using MBQI [@WintersteigerHM13]
  * Use templates to find general instances

### Map Property Fragment [@BradleyMS06]

~ MathPre
MP    & ::= \exists \vec{e} . \forall \vec{u} . \bigwedge (G \Rightarrow F)
G     & ::= G \wedge G | A_G
A_G   & ::= T[u] \simeq T[u] | T[] \not\simeq T[u]
T[x]  & ::= x | e
F     & ::= F \vee F | A_F | \neg A_F
A_F   & ::= T[a[u]] \simeq T[a[u]] 
~

~ Begin Example

Let us express the following in the Map Property Fragment:

* $a$ is equal to $b$ except at index $e$.

* $c$ can only have two values, $e_1$ or $e_2$.

~~ MathPre
  \forall u \ . \ a[u] \simeq e
  \forall u \ . \ u \not\simeq e \ \Rightarrow a[u] \simeq b[u]
  \forall u \ . \ c[u] \simeq e_1 \ \vee c[u] \simeq e_2
~~

~ End Example
 
### Array Property Fragment [@BradleyMS06]

The Array Property Fragment extends the Map Property Fragment by allowing limited arithmetic.

~ MathPre
AP   & ::= \exists \vec{e} . \forall \vec{u} . \bigwedge (G \Rightarrow F)
G    & ::= G \wedge G | A_G
A_G  & ::= T_G \geq T_G
T_G  & ::= u | T[]
T[x]  & ::= x | e | k\times T[x] | T[x] + T[x]
F    & ::= F \vee F | A_F | \neg A_F
A_F  & ::= T_F \geq T_F | R(T_F, \ldots, T_F) 
T_F  & ::= T[a[u]]
k    & ::= \mbox{a numeric constant}
R    & ::= \mbox{a predicate}
~

The claim is that the array property fragment admits a finite set of instantiations.

* Given formula $\varphi := \forall \vec{u} . \bigwedge (G \Rightarrow F)$ with $\vec{e}$ free.

* Let $\mathcal{I} = \{ c_1, \ldots, c_m \}$ be set of a set of $T[] \cup \{ 0 \}$ from $\varphi$.

~ Definition
The set $\mathcal{I}$ is a _sufficient set of instances_ for $\varphi$, if
  
    $\forall u \ . \ \bigvee_{c \in \mathcal{I}} \bigwedge_{A_G} (A_G \Rightarrow A_G[c/u])$
 
~

* In other words, for every possible instantiation of $u$ there is a $c$
  that satisfies at least the same combination of guards.


~ Proposition
  If $\varphi$ admits a finite sufficient set of instances $\mathcal{I}$, it can be evaluated using those.
~

~ Proposition
  Formulas in the array and map property fragments admit a sufficient set of instantiations.
~

~ Proposition
  MBQI is a decision procedure the array and map property fragments by using the
  instantiation sets computed from the formulas.
~

### Essentially Uninterpreted Fragment [@GeM09]

The Array Property Fragment can be seen as an instance of a class of formulas
where instantiations can be extracted based on a set of grammar rules that are extracted
from the formulas.

This fragment thus applies to wider range of formulas than the syntactic array property fragment.
It also captures fragments studied in different contexts:

* the list property fragment by McPeak and Necula
* several locally finite theories by Stokkermans et. al.


~ Begin Example

```smt
(set-option :smt.mbqi true)
;; f an g are "streams"
(declare-fun f (Int) Int)
(declare-fun g (Int) Int)

;; the segment [a, n + a] of stream f is equal to the segment [0, n] of stream g.
(declare-const n Int)
(declare-const a Int)
(assert (forall ((x Int)) (=> (and (<= 0 x) (<= x n))
                              (= (f (+ x a)) (g x)))))

;; adding some constraints to a
(assert (> a 10))
(assert (>= (f a) 2))
(assert (<= (g 3) (- 10)))

(check-sat)
(get-model)
```

~ End Example

## MBP

## Macro Elimination

