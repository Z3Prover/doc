[INCLUDE=presentation]
Title         : Reductions to LIA*
Sub Title     : TU Wien Guest Lectures October 2025
Author        : Nikolaj Bj&oslash;rner
Affiliation   : Microsoft Research
Email         : nbjorner\@microsoft.com
Reveal Theme  : solarized
Beamer Theme  : singapore
Bibliography  : refs.bib
Cite Style    : natural
muZ           : $\mu{Z}$
Package       : [curve]xypic
Package       : tikz
Package       : algorithm2e
Embed         : 1024
Tex Header    : \usetikzlibrary{shapes,snakes}
Css Header:
    .reveal p, .reveal li, .reveal .bibitem, .reveal dd, .reveal dt {
      text-align: left !important;
    }

.Math-Inline,.Math-Display,~Math,~MathPre: 
    replace=//<-/\leftarrow//->/\rightarrow//=>/\Rightarrow//!=/\mathop{\neq}//g 
    replace=//AA/\forall//EE/\exists//g


~ MathDefs
\newcommand{\dbar}{\,|\!|\,}
\newcommand{\searchstate}[2]{#1 \dbar #2}
\newcommand{\conflstate}[3]{#1 \dbar #2 \dbar #3}
\newcommand{\twodpstate}[2]{#1  \dbar #2}
\newcommand{\compl}[1]{\overline{#1}}
\newcommand{\Model}{\mathcal{M}}
\newcommand{\nodefinition}{}
\newcommand{\Mbp}{Mbp}
\newcommand{\Queue}{\mathcal{Q}}
\newcommand{\Init}{\mathit{Init}}
\newcommand{\Safe}{\mathit{Safe}}
\newcommand{\true}{\textsf{true}}
\newcommand{\false}{\textsf{false}}
\newcommand{\cF}{{\mathcal{F}}}
\newcommand{\phidown}{\varphi_{\downarrow}}
\newcommand{\psidown}{\psi_{\downarrow}}
\newcommand{\phiup}{\varphi^{\uparrow}}
\newcommand{\router}[1]{R_{#1}}
\newcommand{\mustsummary}[3]{
\langle #1 \stackrel{\mathtt{must}}{\Longrightarrow}_{#2} #3 \rangle}
\newcommand{\notmaysummary}[3]{
\langle #1 \stackrel{\neg\mathtt{may}}{\Longrightarrow}_{#2} #3 \rangle}
\newcommand{\querysummary}[3]{
\langle #1 \stackrel{?}{\Longrightarrow}_{#2} #3 \rangle}
\newcommand{\dst}{\mathit{dst}}
\newcommand{\src}{\mathit{src}}
\newcommand{\unk}[1]{{\color{blue}{#1}}}
~

[TITLE]

# Example formula {data-transition:none }

~ MathPre
  s \subseteq t \wedge |s| = 1 \wedge |t \setminus s| \neq |t| - 1
~

See [@PiskacK08]

# Step 1 - rewrite with summations

~ MathPre
  s \subseteq t \wedge |s| = 1 \wedge |t \setminus s| \neq |t| - 1
~

To 

~ MathPre
         &  (\sum (e \in s \wedge e \not \in t)) = 0
\wedge &  (\sum e \in s) = 1       
\wedge &  (\sum (e \in t \wedge e \not \in s)) \neq (\sum e \in t) - 1
~

# Step 2 - Introduce auxiliary variables

~ MathPre
  s \subseteq t \wedge |s| = 1 \wedge |t \setminus s| \neq |t| - 1
~

~ MathPre
         
       &  (\sum (e \in s \wedge e \not \in t)) = 0 
\wedge &  (\sum e \in s) = 1       
 \wedge &  (\sum e \in u) \neq (\sum e \in t) - 1
 \wedge &  (\sum e \in u \not\leftrightarrow e \in t \wedge e \not \in s) = 0
~


# Step 3 - Combine summations

~ MathPre
        & k_s = 1 
 \wedge & k_u \neq k_t - 1 
 \wedge & (k_s, k_t, k_u) \in \sum (e \in s, e \in t, e \in u) & \mid (e \not \in s \vee e \in t) 
        &                                                      & \wedge   (e \in u \leftrightarrow e\in t \wedge e \not\in s)
~

* Cardinality constraints added to LIA formula
* Set constraints are under summations

# Step 4 - Boolean reduction

~ MathPre
        & k_s = 1 
 \wedge & k_u \neq k_t - 1 
 \wedge & \displaystyle (k_s, k_t, k_u) \in \sum_{(b_s, b_t, b_u) \in Bool^3} & \mid (\neg b_s \vee b_t) 
        &                                                      & \wedge   (b_u \leftrightarrow b_t \wedge \neg b_s)
~

# Boolean Reduction - General form

~ MathPre
            & F_1(\vec{k}) \land \vec{k} \in \sum_{\vec{b}} F_2(\vec{b})
        F_1: & k_s = 1  \wedge k_u \neq k_t - 1 
        F_2: &  (\neg b_s \vee b_t) \wedge   (b_u \leftrightarrow b_t \wedge \neg b_s)
~

# Solving B*

__Claim__: for set cardinalities we are creating sets based on semi-linear combinations of vectors based on Boolean assignments.
Thus, the vectors are based on satisfying implicants of the formula $F$ under $\sum$.

__General form__:

~ MathPre
  F_1(\vec{k}) \wedge  \vec{k} \in \sum_{\vec{b}} F_2(\vec{b})
~

Define 

~ MathPre
  F_2^*(\vec{k}) & := & \vec{k} \in \sum_{\vec{b}} F_2(\vec{b})
~

# Solving B* with Constrained Horn Clauses (CHC)


~ MathPre
  & \widehat{F}_2^*(\vec{0})
  & \widehat{F}_2^*(\vec{k}) \wedge F_2(\vec{b}) & \implies & \widehat{F}_2^*(\vec{k} + \vec{b})
  & \widehat{F}_2^*(\vec{k})                     & \implies & \neg F_1(\vec{k})
~ 

If this is satisfiable with solution $F_2^*$, then $F_1(\vec{k}) \wedge F_2^*(\vec{k})$ is UNSAT.


Justification: 

* if $\widehat{F}_2^*(\vec{k})$ is a solution to CHC, then ${F}_2^*(\vec{k}) \implies \widehat{F}_2^*(\vec{k})$.

# Solving B* with CHC


~ MathPre
  & \widehat{F}_2^*(\vec{0})
  & \widehat{F}_2^*(\vec{k}) \wedge F_2(\vec{b}) & \implies & \widehat{F}_2^*(\vec{k} + \vec{b})
  & \widehat{F}_2^*(\vec{k})                     & \implies & \neg F_1(\vec{k})
~ 

Conversely, if there is some set of assignments $F_2(\vec{b}_1) \wedge \ldots \wedge F_2(\vec{b}_k)$, 
such that $F_1(\sum \vec{b}_i)$, then it shows that $F_1(\vec{k}) \wedge \vec{k} \in \sum_{\vec{b}} F_2(\vec{b})$.

# State reachability - example

~ MathPre
        F_1: & k_s = 1  \wedge k_u \neq k_t - 1 
        F_2: &  (\neg b_s \vee b_t) \wedge   (b_u \leftrightarrow b_t \wedge \neg b_s)
~

Solutions to $F_2$ are $\{ (0, 0, 0), (1, 1, 0), (0, 1, 1) \}$.

Set $U^* := (k_s, k_t, k_u) = n_1(1,1,0) + n_2(0,1,1) \wedge n_1 \geq 0 \wedge n_2 \geq 0$.

~ MathPre
  k_s = 1 = n_1 \geq 0 \wedge k_t = n_1 + n_2 \wedge k_u = n_2 \wedge k_u \neq k_t - 1
~ 

it is unsat


# B* represents a special case vector addition system

* Pretend it as a state-machine where the initial state is $\vec{0}$.

* $F_2(\vec{b})$ tells us the space of possible increments. 

* The increments are independent of the current state. 

* Each vector fits within a cube (each coordinate is either 0 or 1).

# State reachability is decidable

* Z3 contains an engine for Horn clauses (PDR/SPACER).

* Simple algorithm: Enumerate all solutions $\vec{b}^i$ to $F_2(\vec{b}^i)$. 
* Check satisfiability of $F_1(\sum n^i \cdot \vec{b}^i) \wedge \bigwedge_k n^i \geq 0$. 

# From PDR to conflicts

* Assume we have a set of literals over set constraints and cardinalities of sets.

* We want to check satisfiability of them. 

* Extract $F_1, F_2^*$, solve for $\widehat{F}^*_2$.
  * If the system is unsat: it means there is some solution for sets that satisfy the cardinality constraints.
  * if the system has a solution: it means the conjunction of set constraints cannot satisfy the cardinality constraints.
    * we could look for a subset of set constraints that are sufficient using the unsat core from cardinality constraints.


# State reachability refinements

* Start with initial state $U := \emptyset, U^*(\vec{k}) := (\vec{k} = \sum_{b^i \in U} n^i \cdot b^i) \wedge \bigwedge_i n^i \geq 0$,  
$O := \true$

* While $F_1(\vec{k}) \land U^*$ is unsat and $O \wedge \neg F_1(\vec{k})$ is sat:
  * Check sat of $U^*(\vec{k}) \wedge F_2(\vec{b}) \land \neg U^*(\vec{k}+\vec{b})$.
    * Add new solution $U := U \cup \{ \vec{b}^i \}$.
    * If there are no new solutions $U$ is completed.
  * Dual process for strengthening $O$.

# Over-approximations

~ MathPre
        F_1: & k_s = 1  \wedge k_u \neq k_t - 1 
        F_2: &  (\neg b_s \vee b_t) \wedge   (b_u \leftrightarrow b_t \wedge \neg b_s)
~

~ MathPre
  & k_s \geq 0
\wedge & k_s = 0 \implies k_u = k_t
\wedge & k_s = 1 \implies k_u = k_t - 1
~ 

# Solving Over-approximations

```
(set-logic HORN)
(declare-fun F2Star (Int Int Int) Bool)
(define-fun F2 ((bs Int) (bt Int) (bu Int)) Bool 
    (and (<= 0 bs) (<= bs 1)
         (<= 0 bt) (<= bt 1)
         (<= 0 bu) (<= bu 1)
         (or (= bs 0) (= bt 1))
         (= (= bu 1) (and (= bt 1) (= bs 0)))))
(define-fun F1 ((ks Int) (kt Int) (ku Int)) Bool
    (and (= ks 1) (not (= ku (- kt 1)))))

(assert (F2Star 0 0 0))
(assert (forall ((ks Int) (kt Int) (ku Int) (bs Int) (bt Int) (bu Int))
             (=> (and (F2Star ks kt ku) (F2 bs bt bu)) (F2Star (+ ks bs) (+ kt bt) (+ ku bu)))))


(assert (forall ((ks Int) (kt Int) (ku Int))
(=> (F2Star ks kt ku) (not (F1 ks kt ku)))))

(check-sat)
(get-model)
```

# PDR/IC3 Saturation

~ MathPre 
  \mathcal{F}(\varphi(\vec{k})) & := & F_2(\vec{b}) \wedge \varphi(\vec{k} + \vec{b})
~ 

__Unfold__ $\vec{k} = \vec{0} \implies \neg (k_s = 1 \land k_u \neq k_t - 1)$

  * $N \leftarrow 1$

__Candidate__ $(k_s, k_t, k_u) = (1, 1, 1) \models \true \land k_s = 1 \land k_u \neq k_t - 1$

  * add $\langle \Model = (1,1,1), N = 1 \rangle$ to $\mathcal{Q}$.
  

# PDR/IC3 Conflicts

__Conflict__ 

~ MathPre
\mathcal{F}(k_s \geq 0) 
      \implies k_s + b_s \geq 0
\mathcal{F}(k_s = 0 \implies k_u = k_t) 
      \implies (k_s + b_s = 0 \implies (k_u + b_u = k_t + b_t))
%\mathcal{F}(k_s = 1 \implies k_u = k_t - 1) 
%      \implies (k_s + b_s = 1 \implies k_u + b_u = k_t + b_t - 1)
~

Note that $\Model(k_s, k_t, k_u) = (1, 1, 1)$ and $\Model \models k_s \geq 0$ and 
$k_s = 0 \implies k_u = k_t$.

# PDR/IC3 method of finding inductive predicates

* Model-Based projection

   * Finds some $\pi(y) \implies \exists x \ . \ \varphi(x, y)$

   * Conversely $ \varphi(x, y) \implies \neg \pi(y)$.

* $\neg \pi(y)$ can be added to frames $R_i$ and sometimes inductive across all frames.

# Theory combination

Not all set constraints are _pure_. 

* $X = \{ x \}$ means the set $X$ is a singleton set and if $Y = \{ y \}$ with $x \not\simeq y$, then $Y \neq X$.
* Abstract singleton constraints as sets of size 1 for variables that are distinct. Track distinctness assumptions.

__Claim__: we can eliminate singleton sets and just consider set variables with cardinality 1 from the point of view of the set solver.

* Can anything reasonable be done with ranges, subsets, map?

# Integration - Outline

* Set of literals $\mathcal{L}$ over set constraints.
* All sub-expressions with cardinality operators
* Sub-terms over sets $s \equiv t \cup v, \ldots$.
* Introduce fresh variables for sub-term definitions.
* Define $F_2^*$ for equality constraints. 
* Define $F_1$ for cardinality operators, arithmetic constraints and set disequalities.
* Check reachability. 

# The extra mile

What if we want to solve CHC over finite sets (not just Boolean programs)?

~ MathPre
  R(\emptyset) 
  R(s) \wedge x \in s & \implies & R(s \cup \{ x + 2\})
  R(s) \wedge x \in s & \implies & 4 \uparrow x
~

* Is there a (non-trivial) class of CHC over finite sets that is solvable?
* Trivial := finite sets over finite base sorts

# Bibliography

[BIB]